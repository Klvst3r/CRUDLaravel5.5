31. Usando Eloquent ORM de forma interactiva con Tinker
-------------------------------------------------------


Notas:
======
En esta Seccion se aprendera a interactuar desde la terminal con nuestra aplicación utilizando la consola dinámica Tinker. También veremos nuevos métodos de Eloquent para interactuar con nuestros modelos y aprenderemos cómo crear nuestros propios métodos dentro de los modelos.

Vayamos a cada seccion:



Acceder a Tinker
----------------

Podemos acceder al entorno con el comando de Artisan «tinker»:
	> php artisan tinker

Desde el entorno interactivo podemos ejecutar expresiones de PHP y también vamos a tener disponible las clases de nuestro proyecto y del framework.




Retornar todos los registros con el método all()
------------------------------------------------

Utilizando el «método all()» retornamos todos los registros asociados a un modelo:
---
	$professions = Profession::all();
---



Los métodos «all()» y «get()» en Eloquent retornan colecciones «(objetos de la clase Illuminate\Database\Eloquent\Collection)» las cuales «envuelven» el array de resultados y nos proveen de funciones y métodos adicionales, por ejemplo:

Podemos obtener el primer resultado utilizando el método «first()» y el último utilizando el método «last()». También podemos obtener un resultado aleatorio utilizando el método «random()»:

---
	$profession->first(); // Obtenemos el primer resultado
	$profession->last(); // Obtenemos el último resultado
	$profession->random(1); // Obtenemos un resultado aleatorio
---



Estos métodos de la clase Collection no generan nuevas consultas SQL sino que operan sobre los resultados ya encontrados.




Seleccionar un campo con el método pluck()
------------------------------------------

Utilizando el método «pluck()» podemos retornar una nueva colección que contenga un listado de un solo campo en vez de un listado de objetos. Por ejemplo, podemos obtener solo el campo title de la siguiente forma:

---
	$professions->pluck('title');
---


	Devuelve:
---
	=> Illuminate\Support\Collection {#736
	     all: [
	       "Desarrollador back-end",
	       "Desarrollador front-end",
	       "Diseñador web",
	     ],
	   }
---



Crear una colección de forma manual
-----------------------------------

Con el helper «collect» podemos crear una colección de forma manual:
---
	collect(['Klvst3r', 'crudlaravel', 'Laravel']);
--


Sin embargo éste será un objeto de la clase «Illuminate\Support\Collection» que representa la colección «base» en vez de «Illuminate\Database\Eloquent\Collection».


	## Las colecciones de Eloquent extienden de la colección «base» pero proveen algunos métodos extra asociados al ORM ##



Declarar métodos en el modelo
=============================

Podemos declarar métodos dentro de un modelo y utilizarlos cuando interactuemos con los objetos de estos modelos:


Declarando métodos no estáticos:
--------------------------------

Asociamos un método para ser utilizado sobre un objeto (que representa un registro de la base de datos):
---
	public function isAdmin()
	{
	    return $this->email === 'klvst3r@mail.com';
	}
---


En este caso «isAdmin()» devuelve true si el email del usuario es igual al valor con el que está siendo comparado:
---
	$user = User::find(1);
	$user->isAdmin(); // Devuelve true o false
---


Declarando métodos estáticos:
-----------------------------

Asociamos un método a la clase del modelo como tal, la cual representa el acceso a una tabla de la base de datos. Estos métodos son usados típicamente para consultas:

---
public static function findByEmail($email)
{
    return static::where('email', $email)->first();
}
---

Luego podrás usar «User::findbyEmail('email@aqui.com')» para buscar a un usuario por el campo email y obtener un objeto «User» como resultado (o «null» si no se encuentra ningún registro).





Practica:
=========

Dentro de los multiples beneficios que trae trabajar con el Framework de Laravel, se encuentra el entorno de programación interactiva llamada «Tinker» se puede acceder a dicho entorno con el comando desde la consola y desde el directorio del proyecto:
	> php artisan thinker

Al presionar «enter» ya se esta dentro del entorno interactivo. Desde aca se pueden ejecutar expresiones de PHP por ejemplo se quiere imprimir 

	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> echo "Hello world";
	Hello world⏎
	>>>

Observandose el resultado, pero lo más interesante no es que puedan ejecutarse expresioens de PHP, sino que se tienes disponibles las clases del proyecto y del Framework de Laravel. Por ejemplo ahora se puede intyeractuar con el modelo de «profesioens» de Laravel, de la siguiente manera:


Este metodo «all()» no se ha visto hasta ahora, pero básicamente permite obtener todos los registros asociados a este modelo, en este caso todos los registros dentro de la tabla Professions, al precionar «enter».


*** Problema
	Al ejecutar la consola de Tinker marca el siguiente error:

	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> Profession::all()
	PHP Fatal error:  Class 'Profession' not found in Psy Shell code on line 1


esa característica de Tinker es un poco experimental y está allí por comodidad o como último recurso, si no te funciona simplemente coloca el nombre de espacio completo App\Profession.

También podrías intentar con el siguiente comando
	> composer dump-autoload.


Posterior a la generación de aerchivos optimizados se vulve a intentar utilizando exclusivamente la segunda opción.

Volvemos a ejecutar


	> php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> Profession::all();
	[!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>



Debo advertir que en mi caso existen dos modelos en la siguiente rutas
1. El generado en el ejemplo numero 1 situado en la siguiente ruta:
	\App\

2. El segundo se genero dentro de una Carpeta lamada "Models"
	Por lo que esta en \App\Models\Profession

Laravel toma como base el segundo para la sección correspondiente de esta guia.


***

Notemos que en este caso utilizaremos para importar la clase antes de utilizarla 
 	use App\Models\Profession;
---
Posterior a ello podremos ejecutar el comando requerido sin ninguna compliación
	>>> Profession::all();
	
---

Ejecutamos:
	> php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman

	>>> use App\Models\Profession;

	>>> Profession::all();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4124
	     all: [
	       App\Models\Profession {#4125
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4126
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4127
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> exit


---

Notemos que podemos salir de la consola interactiva con el comando de tinker:

	>>> exit

Para volver a entrar a Tinker
	> php artisan tinker

	>>> use App\Models\Profession;

En este caso importamos con use y luego lo utilizamos
	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> use App\Models\Profession;
	>>> Profession::all();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4122
	     all: [
	       App\Models\Profession {#4123
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4125
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> exit;

	
Ahora si salgo y me vuelvo a conectar a Tinker tambien se puede utilizar el nombre de espacio completo de la siguiente manera;

	>>> App\Models\Profession::all();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4129
	     all: [
	       App\Models\Profession {#4128
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4127
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4134
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>


Por ultimo, si se esta generando error al escribir unicamente Profession, como fue nuestro caso, podemos ejecutar:
	> composer dump-autoload
	Generating optimized autoload files
	Carbon 1 is deprecated, see how to migrate to Carbon 2.
	https://carbon.nesbot.com/docs/#api-carbon-2
	    You can run ".\vendor\bin\upgrade-carbon" to get help in updating carbon and other frameworks and libraries that depend on it.
	> Illuminate\Foundation\ComposerScripts::postAutoloadDump
	> @php artisan package:discover
	Discovered Package: fideloper/proxy
	Discovered Package: laravel/tinker
	Discovered Package: nesbot/carbon
	Package manifest generated successfully.
	Generated optimized autoload files containing 3550 classes


Y luego conectar con tiknker y volver a intentarlo:
	> php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> Profession::all();
	[!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>


Con este componente vamos a poder hacer nuestras pruebas directamente desde la consola sin necesidad de escribir Seeders, sin reejecutarlos o de hacer pruebas en el navegador; sino que se podran ver los resultados inmediatamante.

Es conveniente por que se van a explicar algunos puntos que es mas facil visualizarlos en la consola, en este caso cuando llamemos al metodo «all()» o incluso al metodo «get()».

Ejecutamos:
	 >>> Profession::get();
	 [!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>

Para obtener las profesiones sin importar si nosostros estamos utlizando un codicional u otro parametro para ejecutar las consultas. Nosotros vamos a recibir como resultado un objeto de la clase "Collection" como se aprecio de la extracción del comando anterior:

---
	=> Illuminate\Database\Eloquent\Collection {#4121


Podemos ver erl nombre de espacio completo, como explicamos anteriormente una colección permite	devolver un array de datos, en este caso es un array que contienen objetos de la clase "Profession" eso se explicara en breve, la idea es trabajar con una interfaz orientada o objetos y tener funcionalidades adicionales que no estan inlcuidas en los array por defecto que trae PHP por ejemplo:

Se declara una variable que va a ser igual al resultado de llamar al metodo all() en el modelo Profession.


	>>> $professions = Profession::all();
	[!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the new Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>


Ahora se puede limpiar la consola ahora se puede obtener la primera profesion de la siguiente manera:

	>>> $professoins->first();
	PHP Notice:  Undefined variable: professoins in C:/AppServ/www/dev/CRUDLaravel5.5eval()'d code on line 1
	>>> $professions->first();
	=> App\Models\Profession {#4122
	     id: 1,
	     title: "Back-end developer",
	     created_at: "2022-06-22 22:51:50",
	     updated_at: "2022-06-22 22:51:50",
	   }

 
Utilizando el metodo «first()». Notemos que la primera profession tiene el id:1 y el titulo: "Back-end developer", Pero como podemos imaginar tambien podemos obtener la ultima profesión en esta caso llamando al metodo «last()»

	>>> $professions->last();
	=> App\Models\Profession {#4125
	     id: 3,
	     title: "Web Designer",
	     created_at: "2022-06-22 22:51:50",
	     updated_at: "2022-06-22 22:51:50",
	   }


Podemos ver que la ultima profesion que se creo tiene el id: 3 y el titulo: "Web Designer"

Tambien podemos obtener una profesion de forma aleatoria de la siguiente manera:

  		>>> $professions->random(1);
		=> App\Models\Profession {#4124
		     id: 3,
		     title: "Web Designer",
		     created_at: "2022-06-22 22:51:50",
		     updated_at: "2022-06-22 22:51:50",
		   }


En este caso obtenemos una colección aleatoria con una profesion aleatoria, y podemos omitir el argumento (1) y en este caso este metodo va a retornar un solo objeto de la clase Profession


	>>> $professions->random(1);
	=> Illuminate\Database\Eloquent\Collection {#3191
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> 


Hay muchs operaciones que podemos hacer cuando trabajamos con colecciones; por ejemplo, vamos a suponer que nos interesa obtener unicamente el campo "title".


En este caso podemos utilizar el metodo «pluck()». 

	>>> $professions->pluck('title');
	=> Illuminate\Support\Collection {#3185
	     all: [
	       "Back-end developer",
	       "Front-end developer",
	       "Web Designer",
	     ],
	   }
	>>>


Aca nuevamente obtenemos una colecion como resultado pero notemos que el array de datos ya no contiene objetos de la clase Profession, sino que contiene cadenas de texto, y cada titulo es una cadena. Esto se logra con el metodo «pluck()». 


Las coleciones de Laravel tambien son inmutables, es decir que por ejemplo para llamar a este metodo no va a modificar mi coleccion original, 


	>>> $professions
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>


Vamos a probar nuevamante.

Vamos a declarar otra veiable llamada $titles para almacenar la coleccion con los titulos de las profesiones, ahora podemos ver el objeto que tengo almacenado en la variable $titles, Pero podemos fijarnos que el objeto que se tiene almacenado en la variable "$professions" no cambia.


	>>> $professions;
	=> Illuminate\Database\Eloquent\Collection {#4122
	     all: [
	       App\Models\Profession {#4123
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4125
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> $titles = $professions->pluck('title');
	=> Illuminate\Support\Collection {#3193
	     all: [
	       "Back-end developer",
	       "Front-end developer",
	       "Web Designer",
	     ],
	   }
	>>> $titles
	=> Illuminate\Support\Collection {#3193
	     all: [
	       "Back-end developer",
	       "Front-end developer",
	       "Web Designer",
	     ],
	   }
	>>>



De igual forma si 


5'19









Ejercicios:
===========

Cuando pongo "Calendar::all()" en Tinker, me sale el siguiente error:

>>>
	PHP fatal error: Class 'Calendar' not found in Psy Shell code on line 1.

Yo tengo un controlador llamado Calendar, de hecho, he venido haciendo todo el curso con "Calendar" en vez de "Profession"ya que intento hacer un calendario en mi proyecto.

Entonces, para para la sección anterior en vez de crear un controlador Profession, lo hice "Calendar". Todo lo que trabajamos en la sección anterior me funcionó perfectamente, pero en este caso Tinker no me consigue eso.

Leí que puede ser por el namespace del controlador, pero no tiene mucho sentido puesto que "User" también tiene de namespace "App" y Tinker si me lo encuentra.

	Para mí esa característica de Tinker es un poco experimental y está allí por comodidad o como último recurso, si no te funciona simplemente coloca el nombre de espacio completo App\Calendar.

	También podrías intentar con composer dump-autoload.

	++

	Ya lo resolví, tuve que usar "composer dump-autoload" y luego intenté de nuevo y solventó.
	

- * - * -

Cual es la diferencia de usar «$user->find()» y «User::find()»; 	

	Es lo mismo, lo que pasa es que en $user ya deberia tener el modelo de User.
	$user = new User();
	$user->find(1);

- * - * -
Como es que desde los seeders puedes hacer «Profession::create(['title']=>'Desarrolador'])»; sin haber puesto 'title' en la variable $fillable del modelo ?
	
	Es porque en los seeders se invoca al metodo desde Model::unguarded ?

	Esa es la respuesta correcta ;) Model::unguarded() desabilita la protección de asignación masiva para todos los atributos del modelo, aun cuando el modelo tengas $fillable o $guarded definido. Así que usa el método con precaución

- * - * -

	Si se tuvo problemas de asignación en masa a la hora de crear un nuevo usuario desde Tinker, por ejemplo:

	$anotherUser=User::create(['user_profession_id'=>'1', 'user_firstname'=>'Pedrito', 'user_secondname'=>'Picapiedras', 'user_lastname'=>'Roca Dura', 'user_email'=>'picapiedras@gmail.com', 'user_password'=>bcrypt(123456), 'user_phone'=>'1234567890', 'user_gender'=>'Male', 'user_is_active'=>1, 'user_kind'=>'Administrator']);

	Recuerde que primero debe agregar esos campos al array protected $fillable al inicio de la declaración del Model. O sea, ponerlos como "rellenables" o que pueden ser asignados en masa desde Tinker:

	/**
	* The attributes that are mass assignable.
	*
	* @var array
	*/
	protected $fillable = [
	'user_profession_id',
	'user_firstname',
	'user_secondname',
	'user_lastname',
	'user_email',
	'user_password',
	'user_phone',
	'user_gender',
	'user_is_active',
	'user_kind',
	];


- * - * -

Surge este error, que cuando se ejecuta 'findByEmail()' me devuelve siempre y solamente el primer User. Por que puede ser?
	
	porque se esta usando ->first() con eso solo devuelve el primer valor que encuentra, y adicionalmente hay un solo usuario con el correo que le esta pasando como parametro.

- * - * -

