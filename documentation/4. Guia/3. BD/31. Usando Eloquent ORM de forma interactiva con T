31. Usando Eloquent ORM de forma interactiva con Tinker
-------------------------------------------------------


Notas:
======
En esta Seccion se aprendera a interactuar desde la terminal con nuestra aplicación utilizando la consola dinámica Tinker. También veremos nuevos métodos de Eloquent para interactuar con nuestros modelos y aprenderemos cómo crear nuestros propios métodos dentro de los modelos.

Vayamos a cada seccion:



Acceder a Tinker
----------------

Podemos acceder al entorno con el comando de Artisan «tinker»:
	> php artisan tinker

Desde el entorno interactivo podemos ejecutar expresiones de PHP y también vamos a tener disponible las clases de nuestro proyecto y del framework.




Retornar todos los registros con el método all()
------------------------------------------------

Utilizando el «método all()» retornamos todos los registros asociados a un modelo:
---
	$professions = Profession::all();
---



Los métodos «all()» y «get()» en Eloquent retornan colecciones «(objetos de la clase Illuminate\Database\Eloquent\Collection)» las cuales «envuelven» el array de resultados y nos proveen de funciones y métodos adicionales, por ejemplo:

Podemos obtener el primer resultado utilizando el método «first()» y el último utilizando el método «last()». También podemos obtener un resultado aleatorio utilizando el método «random()»:

---
	$profession->first(); // Obtenemos el primer resultado
	$profession->last(); // Obtenemos el último resultado
	$profession->random(1); // Obtenemos un resultado aleatorio
---



Estos métodos de la clase Collection no generan nuevas consultas SQL sino que operan sobre los resultados ya encontrados.




Seleccionar un campo con el método pluck()
------------------------------------------

Utilizando el método «pluck()» podemos retornar una nueva colección que contenga un listado de un solo campo en vez de un listado de objetos. Por ejemplo, podemos obtener solo el campo title de la siguiente forma:

---
	$professions->pluck('title');
---


	Devuelve:
---
	=> Illuminate\Support\Collection {#736
	     all: [
	       "Desarrollador back-end",
	       "Desarrollador front-end",
	       "Diseñador web",
	     ],
	   }
---



Crear una colección de forma manual
-----------------------------------

Con el helper «collect» podemos crear una colección de forma manual:
---
	collect(['Klvst3r', 'crudlaravel', 'Laravel']);
--


Sin embargo éste será un objeto de la clase «Illuminate\Support\Collection» que representa la colección «base» en vez de «Illuminate\Database\Eloquent\Collection».


	## Las colecciones de Eloquent extienden de la colección «base» pero proveen algunos métodos extra asociados al ORM ##



Declarar métodos en el modelo
=============================

Podemos declarar métodos dentro de un modelo y utilizarlos cuando interactuemos con los objetos de estos modelos:


Declarando métodos no estáticos:
--------------------------------

Asociamos un método para ser utilizado sobre un objeto (que representa un registro de la base de datos):
---
	public function isAdmin()
	{
	    return $this->email === 'klvst3r@mail.com';
	}
---


En este caso «isAdmin()» devuelve true si el email del usuario es igual al valor con el que está siendo comparado:
---
	$user = User::find(1);
	$user->isAdmin(); // Devuelve true o false
---


Declarando métodos estáticos:
-----------------------------

Asociamos un método a la clase del modelo como tal, la cual representa el acceso a una tabla de la base de datos. Estos métodos son usados típicamente para consultas:

---
public static function findByEmail($email)
{
    return static::where('email', $email)->first();
}
---

Luego podrás usar «User::findbyEmail('email@aqui.com')» para buscar a un usuario por el campo email y obtener un objeto «User» como resultado (o «null» si no se encuentra ningún registro).





Practica:
=========

Dentro de los multiples beneficios que trae trabajar con el Framework de Laravel, se encuentra el entorno de programación interactiva llamada «Tinker» se puede acceder a dicho entorno con el comando desde la consola y desde el directorio del proyecto:
	> php artisan thinker

Al presionar «enter» ya se esta dentro del entorno interactivo. Desde aca se pueden ejecutar expresiones de PHP por ejemplo se quiere imprimir 

	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> echo "Hello world";
	Hello world⏎
	>>>

Observandose el resultado, pero lo más interesante no es que puedan ejecutarse expresioens de PHP, sino que se tienes disponibles las clases del proyecto y del Framework de Laravel. Por ejemplo ahora se puede intyeractuar con el modelo de «profesioens» de Laravel, de la siguiente manera:


Este metodo «all()» no se ha visto hasta ahora, pero básicamente permite obtener todos los registros asociados a este modelo, en este caso todos los registros dentro de la tabla Professions, al precionar «enter».


*** Problema
	Al ejecutar la consola de Tinker marca el siguiente error:

	$ php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> Profession::all()
	PHP Fatal error:  Class 'Profession' not found in Psy Shell code on line 1


esa característica de Tinker es un poco experimental y está allí por comodidad o como último recurso, si no te funciona simplemente coloca el nombre de espacio completo App\Profession.

También podrías intentar con el siguiente comando
	> composer dump-autoload.


Posterior a la generación de aerchivos optimizados se vulve a intentar utilizando exclusivamente la segunda opción.

Volvemos a ejecutar


	> php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman
	>>> Profession::all();
	[!] Aliasing 'Profession' to 'App\Models\Profession' for this Tinker session.
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4121
	     all: [
	       App\Models\Profession {#4122
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4123
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4124
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>>



Debo advertir que en mi caso existen dos modelos en la siguiente rutas
1. El generado en el ejemplo numero 1 situado en la siguiente ruta:
	\App\

2. El segundo se genero dentro de una Carpeta lamada "Models"
	Por lo que esta en \App\Models\Profession

Laravel toma como base el segundo para la sección correspondiente de esta guia.


***

Notemos que en este caso utilizaremos para importar la clase antes de utilizarla 
 	use App\Models\Profession;
---
Posterior a ello podremos ejecutar el comando requerido sin ninguna compliación
	>>> Profession::all();
	
---

Ejecutamos:
	> php artisan tinker
	Psy Shell v0.9.12 (PHP 7.3.10 — cli) by Justin Hileman

	>>> use App\Models\Profession;

	>>> Profession::all();
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	PHP Deprecated:  The "Doctrine/Common/Inflector/Inflector::pluralize" method is deprecated and will be dropped in doctrine/inflector 2.0. Please update to the n
	ew Inflector API. in C:/AppServ/www/dev/CRUDLaravel5.5/vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.php on line 264
	=> Illuminate\Database\Eloquent\Collection {#4124
	     all: [
	       App\Models\Profession {#4125
	         id: 1,
	         title: "Back-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4126
	         id: 2,
	         title: "Front-end developer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	       App\Models\Profession {#4127
	         id: 3,
	         title: "Web Designer",
	         created_at: "2022-06-22 22:51:50",
	         updated_at: "2022-06-22 22:51:50",
	       },
	     ],
	   }
	>>> exit


---

Notemos que podemos salir de la consola interactiva con el comando de tinker:

	>>> exit

Para volver a entrar a Tinker

	1'35

















Ejercicios:
===========

Cuando pongo "Calendar::all()" en Tinker, me sale el siguiente error:

>>>
	PHP fatal error: Class 'Calendar' not found in Psy Shell code on line 1.

Yo tengo un controlador llamado Calendar, de hecho, he venido haciendo todo el curso con "Calendar" en vez de "Profession"ya que intento hacer un calendario en mi proyecto.

Entonces, para para la sección anterior en vez de crear un controlador Profession, lo hice "Calendar". Todo lo que trabajamos en la sección anterior me funcionó perfectamente, pero en este caso Tinker no me consigue eso.

Leí que puede ser por el namespace del controlador, pero no tiene mucho sentido puesto que "User" también tiene de namespace "App" y Tinker si me lo encuentra.

	Para mí esa característica de Tinker es un poco experimental y está allí por comodidad o como último recurso, si no te funciona simplemente coloca el nombre de espacio completo App\Calendar.

	También podrías intentar con composer dump-autoload.

	++

	Ya lo resolví, tuve que usar "composer dump-autoload" y luego intenté de nuevo y solventó.
	

- * - * -

Cual es la diferencia de usar «$user->find()» y «User::find()»; 	

	Es lo mismo, lo que pasa es que en $user ya deberia tener el modelo de User.
	$user = new User();
	$user->find(1);

- * - * -
Como es que desde los seeders puedes hacer «Profession::create(['title']=>'Desarrolador'])»; sin haber puesto 'title' en la variable $fillable del modelo ?
	
	Es porque en los seeders se invoca al metodo desde Model::unguarded ?

	Esa es la respuesta correcta ;) Model::unguarded() desabilita la protección de asignación masiva para todos los atributos del modelo, aun cuando el modelo tengas $fillable o $guarded definido. Así que usa el método con precaución

- * - * -

	Si se tuvo problemas de asignación en masa a la hora de crear un nuevo usuario desde Tinker, por ejemplo:

	$anotherUser=User::create(['user_profession_id'=>'1', 'user_firstname'=>'Pedrito', 'user_secondname'=>'Picapiedras', 'user_lastname'=>'Roca Dura', 'user_email'=>'picapiedras@gmail.com', 'user_password'=>bcrypt(123456), 'user_phone'=>'1234567890', 'user_gender'=>'Male', 'user_is_active'=>1, 'user_kind'=>'Administrator']);

	Recuerde que primero debe agregar esos campos al array protected $fillable al inicio de la declaración del Model. O sea, ponerlos como "rellenables" o que pueden ser asignados en masa desde Tinker:

	/**
	* The attributes that are mass assignable.
	*
	* @var array
	*/
	protected $fillable = [
	'user_profession_id',
	'user_firstname',
	'user_secondname',
	'user_lastname',
	'user_email',
	'user_password',
	'user_phone',
	'user_gender',
	'user_is_active',
	'user_kind',
	];


- * - * -

Surge este error, que cuando se ejecuta 'findByEmail()' me devuelve siempre y solamente el primer User. Por que puede ser?
	
	porque se esta usando ->first() con eso solo devuelve el primer valor que encuentra, y adicionalmente hay un solo usuario con el correo que le esta pasando como parametro.

- * - * -

