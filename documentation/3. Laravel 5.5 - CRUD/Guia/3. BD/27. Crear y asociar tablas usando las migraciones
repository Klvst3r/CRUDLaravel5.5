27. Crear y asociar tablas usando las migraciones de Laravel (con claves foráneas)


Notas
=====

En esta sección del Capitulo 3 de la guia del Framework de Laravel desde cero veremos más a fondo el sistema de migraciones de Laravel. En esta oportunidad, veremos cómo crear nuevas tablas y cómo crear asociaciones entre una tabla y otra utilizando claves foráneas. También veremos un poco más sobre las convenciones que podemos utilizar al momento de generar nuevas migraciones y sobre otros métodos para definir campos.

Convenciones al ejecutar migraciones
------------------------------------

Al generar una migración con el comando php artisan make:migration si utilizamos el siguiente formato para el nombre: create_NOMBRE DE LA TABLA_table, Laravel automáticamente generará el código requerido para crear dicha tabla:
php artisan make:migration create_professions_table

Producirá el siguiente código boilerplate:
----
	public function up()
	{
	    Schema::create('professions', function (Blueprint $table) {
	        $table->increments('id');
	        $table->timestamps();
	    });
	}

---

Ahora sólo tenemos que definir las columnas.

También podemos pasar la opción --create en caso de que no queramos usar la convención:
	php artisan make:migration new_professions_table --create=professions

A la opción create pasamos como valor el nombre de la tabla.



Restricción de clave foránea
----------------------------
Podemos añadir una restricción de clave foranea a nuestro campo utilizando el método foreign():
---
	Schema::create('users', function (Blueprint $table) {
	    // ...
	    $table->unsignedInteger('profession_id'); 
	    $table->foreign('profession_id')->references('id')->on('professions');
	    // ...
	});
---

En este caso indicamos que el campo profession_id va a hacer referencia al campo id en la tabla professions.

Aquí es importante que el tipo del campo profession_id coincida con el campo id en la tabla professions. Es decir el campo profession_id debe ser definido como un entero positivo, para ello usamos el método:

$table->unsignedInteger('nombre_del_campo_aqui'); o $table->integer('nombre_del_campo')->unsigned();


Claves primarias
----------------
Cuando diseñamos una base de datos, suele ser importante tener un campo (o combinación de campos) que pueda identificar de manera única a cada fila. Así como se tiene un número de pasaporte que es único, cada usuario o profesión va a tener un identificador (id) único. En esta base de datos usaremos identificadores de tipo auto-incremento, es decir la primera fila obtendrá el identificador 1, la segunda 2, y así sucesivamente. Estos identificadores serán generados por el motor de la base de datos.



Claves Foráneas
---------------
Para asociar una tabla con otra, vamos a utilizar una clave foránea. Por ejemplo en la tabla de usuarios, utilizaremos el campo profession_id, cuyo valor va a ser un identificador (id) válido de uno de los registros de la tabla de profesiones. De esta manera asociaremos un registro (fila) la tabla usuarios con un registro (fila) de la tabla de profesiones. En este tipo de relaciones solemos decir que un Usuario pertenece a una Profesión. También podemos decir que una Profesión tiene muchos Usuarios. Puesto que pueden existir 100 usuarios que sean desarrolladores back-end o 50 usuarios que sean desarrolladores front-end, cada profesión va a tener asignada muchos usuarios. Por otro lado cada usuario solo puede tener asignada una profesión (aunque en la vida real hay personas que tienen más de una profesión, en nuestro sistema esto no es relevante).



Practica
========


Cuando se comienza con el desarrollo de un proyecto con Laravel, no se suele empezar creando toda las tablas, es decir todas las migraciones, ni diseñando la base de datos primero que nada. Sino que se puede comentar con las pruebas automatizadas vistas en secciones atras. Y son estas pruebas las que suelen indicar que tablas, y columnas se deben crear. Y asi se va poco a poco estructurando la BD, sin embargo se ha pretendido exoplicar con esta guia desde cero de forma que vayamos aprendiendo componente por compomenente. 

En esta sección vamos a aprender más sobre el sistema de migraciones de Laravel. 

Suponiendo que ya tenemos nuestro formulario de registro y que ya se tienen usuarios registrandose en nuesto proyecto, y nos hemos dado cuenta que varios usuarios que se han registrado tienen la misma profesión, sin embargo la han escrito de forma diferente; por ejemplo, el primer usuario escribio "Backend developer", el segundo "Back-end developer" y un tercero "Back-end programmer". Entonces tenemos tres usuarios que tienen la misma profesión, pero estan escritas de forma diferente y esto va a dificultar que nosotros puedamos hacer busquedas o mostrar resultados dependiendo de la profesion que tengan. Asi deberiamos solucionarlo de una mejor manera y seguramente hemos padecido esta situacion en donde para registrar la profesión debemos seleccionarla de una lista y no escribirla en un campo de texto. Esto es lo que se pretende aca. 

Primero a nivel de base de datos y más adelante en secciones futuras en un formulario de busqueda.

Para ello, vamoa a regresar a la consola y vamos a crear una nueva migración:
	> php artisan make:migration create_professions_table


Puesto que se va a querer crear una tabla de profesiones, y es ahi donde vamos a colocar las profesiones que consideramos validas para que el usuario seleccione una al momento de registra su información en el formulario o de editar su perfil de usuario. 	


Regresando al editor veremos que ahora tenemos un nuevo archivo de migración, y como utilizamos una foram de convención, Laravel automaticamente nos va a dar el codivo boilerplate para crear la tabla de profesiones:

---2022_06_06_174018_create_professions_table.php
...
	public function up()
    {
        Schema::create('professions', function (Blueprint $table) {
            $table->increments('id');
            $table->timestamps();
        });
    }
...
---


Podemos demostrar como funciona esto si se inspecciona una de las clases del Framework que se llama "MigrateMakeCommand"

En la ruta:
	C:\AppServ\www\dev\CRUDLaravel5.5\vendor\laravel\framework\src\Illuminate\Database\Console\Migrations
---
...
	class MigrateMakeCommand extends BaseCommand
{
    /**
     * The console command signature.
     *
     * @var string
     */
    protected $signature = 'make:migration {name : The name of the migration.}
        {--create= : The table to be created.}
        {--table= : The table to migrate.}
        {--path= : The location where the migration file should be created.}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Create a new migration file';
...
---	


Esta es la clase donde va a estar el codigo para generar una nueva migracion, donde se puede ver la declaración del comando, pero lo que se pretender ver es lo siguiente en el mismo archivo:
---
...line 86
if (! $table) {
            if (preg_match('/^create_(\w+)_table$/', $name, $matches)) {
                $table = $matches[1];

                $create = true;
            }
        }
...
---

Que en el metodo "handle" que se va a encargar de crear esta migración Laravel en elgun momento va a revisar si el patrón que se esta utilizando para el nombre de la migración incluye el prefijo "create" y el subfijo "table". De ser asi entonces Laravel automaticamente va a generar el código boilerplate para que entonces se pueda crear una nueva tabla, esto no va a suceder si uno por ejemplo ejecuta el comando:
	> php artisan make:migration new_professions_table

Si escribimos de esta manera el comando y regresamos a la migración notaremos que no tenemos el codigo boilerplate para crear una nueva tabla

---
class NewProfessionsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        //
    }

---


Por supuesto uno puede escribirlo rapidamente, pero si utilizamos la convención entonces ahorraremos algo de tiempo, tambien podremos especificar esto manualmente si no quememos utilizar la convencion, ejecutando:

Sintaxis
	> php artisan make migration <nombre_archivo> --create=<nombre_tabla>

Comando:
	> php artisan make:migration new_professions_table --create=professions


Regresando al editor y abriendo la migración creada podremos observar que se tiene creada el codigo boilerplate con la utilización del parametro "--create" volvemos a tener el codigo boilerplate para comenzar a crear nuestra tabla en el metodo up() y en el metodo down(), debemos fijarnos que tenemos el codigo para crear y eliminar la tabla respectimanete. Esto fue agregado por Laravel automaticamente al momento de crear la nueva migración.

Vamos  a trabajar con la primera migración que se creo, entonces queremos que la tabla tenga:

---2022_06_06_174018_create_professions_table.php
...
	public function up()
    {
        Schema::create('professions', function (Blueprint $table) {
            $table->increments('id');

			$table->increments('title', 100);	

            $table->timestamps();
        });
    }
...
---

Si regresamos a la consola y ejecutamos el comando:
	> php artisan migrate


puedo entonces ir a PHPmyAdmin y ver que tengo una nueva tabla llamada profesions, sin embargo yo en la tabla de usuarios aun tengo 

+------------+------------------+------+-----+---------+----------------+
| Field      | Type             | Null | Key | Default | Extra          |
+------------+------------------+------+-----+---------+----------------+
| id         | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| title      | varchar(100)     | NO   |     | NULL    |                |
| created_at | timestamp        | YES  |     | NULL    |                |
| updated_at | timestamp        | YES  |     | NULL    |                |
+------------+------------------+------+-----+---------+----------------+


Más sin embargo en la tabla de usuarios aun se tiene la columna:


+----------------+------------------+------+-----+---------+----------------+
| Field          | Type             | Null | Key | Default | Extra          |
+----------------+------------------+------+-----+---------+----------------+
| id             | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| name           | varchar(255)     | NO   |     | NULL    |                |
| email          | varchar(255)     | NO   | UNI | NULL    |                |
| password       | varchar(255)     | NO   |     | NULL    |                |
| profession     | varchar(50)      | YES  |     | NULL    |                | <- Es una cadena de Texto
| remember_token | varchar(100)     | YES  |     | NULL    |                |
| created_at     | timestamp        | YES  |     | NULL    |                |
| updated_at     | timestamp        | YES  |     | NULL    |                |
+----------------+------------------+------+-----+---------+----------------+


Pero deseamos que esta columna "profession" que es una cadena de texto, pero queremos que ahora esta columna permita asociar a cada usuario registrado en el sistema con un profesion de la tabla professions, y puesto que cada profesion va a tener un "id" o un identificador, Vamos a desmostrarlo de la siguiente manera:

Agregamos dos profesiones

	- Back-end developer
	- Front-end developer

Mas adelante veremos como podemos insertar esta información directamente con Laravel, pero ahora lo haremos de manera manual, po lo que. Via phpmyadmin

-*-*
	INSERT INTO `professions` (`id`, `title`, `created_at`, `updated_at`) VALUES (NULL, 'Back-end developer', NULL, NULL), (NULL, 'Front-end developer', NULL, NULL);
-*-*


+----+---------------------+------------+------------+
| id | title               | created_at | updated_at |
+----+---------------------+------------+------------+
|  1 | Back-end developer  | NULL       | NULL       |
|  2 | Front-end developer | NULL       | NULL       |
+----+---------------------+------------+------------+

Ya tenemos dos profesiones en el sistema, cada una de ellas tiene un identificador, y puesto que la intencion es asociar a cada uno de los usuaarios en el sistema, con una de las profesiones ya existentes en la tabla professions. vamos a utilizar no una cadena de texto, sino un entero sin signo, para que cada registro tenga relacion con el indentificador de la trabla "professions". 

Asi por ejemplo la profession "Back-end developer" tiene el id 1, entones en la columna 

+----------------+------------------+------+-----+---------+----------------+
| Field          | Type             | Null | Key | Default | Extra          |
+----------------+------------------+------+-----+---------+----------------+
| id             | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| name           | varchar(255)     | NO   |     | NULL    |                |
| email          | varchar(255)     | NO   | UNI | NULL    |                |
| password       | varchar(255)     | NO   |     | NULL    |                |
| profession     | varchar(50)      | YES  |     | NULL    |                | <- Een ves de almacenar la cadena de texto "Back-end developer" vamos a almacenar el valor 1
| remember_token | varchar(100)     | YES  |     | NULL    |                |
| created_at     | timestamp        | YES  |     | NULL    |                |
| updated_at     | timestamp        | YES  |     | NULL    |                |
+----------------+------------------+------+-----+---------+----------------+


Y cuando en BD se utiliza un acolumna para hacer referencia con otra tabla se le da el nombre de clave foranea o llave foranea, puesto que esta columna que tienemos en la tabla professions, es la llave primaria de la tabla es decir el identificador unico para cada registro de esta tabla, para cuando queramos hacer referencia a una llave o clave ajena de esta tabla, entonces se le da el nombre de llave o clave foranea, y para identificar que una columna va a ser una clave foranea solemao darle el subfijo de "_id" o "id". Asi que vamos a crar una nueva migracion con el comando:
	> php artisan make:migration add_profession_id_to_users

Es decir vamos a agregar la columna "profession_id"	 a la tabla "users".

Ya en la migración:


---2022_06_07_154449_add_profession_id_to_users
...
	 public function up()
    {
        Schema::table('users', function(Blueprint $table){
            $table->dropColumn('profession');

            $table->unsignedInteger('profession_id');
        });
    }
...
---

Se comienza a escribir esta migración nuevamente, utilizando el Phasas "Schema" con el nombre de la tabla va a ser 'users' nuevamente y nuevamente vamos a utilizar una funcion anonima con el objeto de la clase "Blueprint" para eliminar la columna profession y agregar otra columna que llamara "profesion_id" y esta columna va a ser un entero sin signo, es decir un entero positivo.

Puedo hacerlo de esta manera o utilizar el metodo integer() y luego encadenar el metodo unsigned(), somo se muestra a continuación:

---2022_06_07_154449_add_profession_id_to_users
...
	 public function up()
    {
        Schema::table('users', function(Blueprint $table){
            $table->dropColumn('profession');

            $table->integer('profession_id')->unsigned();
        });
    }
...
---

Ahora en el metodo down(), queremos hacer la operación contraria, 
 
 ---2022_06_07_154449_add_profession_id_to_users
 ...

	  public function down()
	    {
	        Schema::table('users', function(){
	            $table->dropColumn('profession_id');

	            $table->string('profession', 50)->nullable()->after('password');
	        });
	    }
 ...
 ---



Aqui quiero eliminar la columna "profession_id" y crear nuevamente la columna "profession" despues de la columna password de tipo string con longitud de 50 caracteres.

Probamos regresando a la consola:
	> php artisan migrate 

Y podemos ver si regreso ahora a a ver la estructura de la tabla y podemos observar que ahora tenemos la columna profession_id


+----------------+------------------+------+-----+---------+----------------+
| Field          | Type             | Null | Key | Default | Extra          |
+----------------+------------------+------+-----+---------+----------------+
| id             | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| name           | varchar(255)     | NO   |     | NULL    |                |
| email          | varchar(255)     | NO   | UNI | NULL    |                |
| password       | varchar(255)     | NO   |     | NULL    |                |
| remember_token | varchar(100)     | YES  |     | NULL    |                |
| created_at     | timestamp        | YES  |     | NULL    |                |
| updated_at     | timestamp        | YES  |     | NULL    |                |
| profession_id  | int(10) unsigned | NO   |     | NULL    |                |
+----------------+------------------+------+-----+---------+----------------+


Ahora podemos ver que tenemos la columna "profession_id" y ya no tenemos la columna "profession". Sin embargo nuestras migraciones estan un poco desordenadas, por que si regresamos al editor tenemos una migración para agragar una columna, pero luego tenemos una migración para eliminar la misma columna, 


---
<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddProfessionIdToUsers extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('users', function(Blueprint $table){
            $table->dropColumn('profession');

            $table->unsignedInteger('profession_id');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('users', function(){
            $table->dropColumn('profession_id');

            $table->string('profession', 50)->nullable()->after('password');
        });
    }
}


---


Esto puede hacerse un poco dificil de leel, casos como este que apenas estamos comenzando el desarrollo de nuestro proyecto donde no tenemos una base de datos en producción y no tenemos datos reales, etc.

En vez de estar agregando un monton de migraciones sin sentido, nosotros simplemente podemos modificar migraciones ya existentes y recrear la base de datos, por ejemplo:


---
	$table->unsignedInteger('profession_id');
---
Yo puedo directamente puedo agregar la columna "profession_id" que va a ser una columna que simplemente va a ser un entero sin signo, es decir un entero positivo y puedo agregar esta columna directamente a la tabla de usuarios en la migracion de ["...create_users_table.php"]. De esta manera ya no voy a necesitar las dos migraciones (...add_profession_to_users.php y ...add_profession_id_to_users.php)

---...create_users_table.php


---

















Ejercicio
=========

¿Crear migraciones o modificar las ya existentes?
-------------------------------------------------

Para evitar que el número de migraciones crezca sin control, puede modificar las migraciones ya existentes. Tenga en cuenta que esto suele ser posible en etapas tempranas del desarrollo donde la base de datos no existe en producción y todos los datos son de prueba (no importa destruir y reconstruir la base de datos cada vez). Si luego de 3 meses de lanzar su proyecto debe agregar un campo a la tabla de usuarios, en este caso le recomendaría crear una migración nueva. Porque así no solo podrá modificar la tabla de usuarios (sin eliminarla y recrearla) sino que además mantendrá un historial de los cambios que se han producido en diferentes versiones de su aplicación.


Cambié una migración y ya nada funciona…
---------------------------------------
En casos donde ejecutar php artisan migrate:refresh y comandos similares, siempre produzca un error, puede solucionarlo borrando todas las tablas de su base de datos o ejecutando:
	> php artisan migrate:fresh.

Tenga en cuenta que ejecutar php artisan migrate:fresh va a eliminar todas las tablas. Hagalo solamente si no le importa perder los datos (porque solo son de prueba, etc).

Aunque podria hacer un respaldo de esa información para luego importarla, segun se requiera, siempre y cuando estructuralmente no existan cambios y los mismos dagtos no creen conflicto en el desarrollo del proyecto.



Comentarios almomento de crear llaves foraneas, aplica para versiones posteriores al a 5.5

Para los que tienen problemas en crear las llaves foranes en las nuevas versiones de Laravel utilicen o cambien la función unsignedInteger() por unsignedBigInteger()

YA NO FUNCIONA EL (unsignedInteger) en laravel 5.8-> me genero mucho estres.

Debido a que laravel ahora usa de forma predeterminada "bigIncrements", tienes que usar "unsignedBigInteger" para hacer referencias a esta columna
	o bien $table->bigInteger('id')->unsigned();



Referencias
===========

Variables de Entorno en Laravel
-------------------------------
Con el uso de las credenciales y nuestra configuración de la base de datos en el archivo .env siempre sera distinto o al menos la mayoria de las veces en un entorno local de desarrollo que en un entorno de producción, es por ello que vamos a hacer referencia al tema de "Variables de entorno en laravel" Esta referencia se encentra dentro de las referencias del capitulo 3. con el mismo nombre.



Comentarios
-----------

Comentario 1: cuando creo una tabla nueva como 'professions' que deba enlazarla a 'users' con la clave foránea 'professions_id', siento cómodo crear una migración donde dentro del mismo up() creo la tabla 'professions' y además añado en 'users' la columna 'professions_id' y la clave foránea correspondiente. En este ejercicio no se a intentado hacer así y a mí me resulta intuitivo y cómodo, pero la consulta es: ¿Puede traerme complicaciones en el futuro estructurarlo así?


Comentario 2:
Escribir el comando php artisan make:migration add_profession_id_to_users al final tambien le agregan lo siguiente table=users Para que ahorren tener que especificar la tabla despues de que se genere el archivo de migraccion.
Quedando:
	> php artisan make:migration add_profession_id_to_users --table=users

Comentario 3:
En el metodo down hay que especificarlo como un array $table->dropForeign(['profession_id']); y si no coloco [ ] genera un error cuando ejecuto el comando php artisan migrate:refresh	
	No habia notado que colocaba corchetes dentro de dropForeign([''])
	Por si ayuda tambien se puede hacer sin corchetes pero se usa el nombre de la restriccion como tal
	Por ejemplo en lugar de
	$table->dropForeign(['profession_id']);
	Uso
	$table->dropForeign('profession_id_foreign'); // Siendo profession_id_foreign el nombre que mysql le da a la restriccion	

Comentario 4:
En el archivo de migración de la tabla professions crea los siguientes campos:

Schema::create('professions', function (Blueprint $table) {
$table->increments('id');
$table->string('title');
$table->timestamps();
});

En el archivo de migración de la tabla users debes crear primero el campo profession_id para poder hacer la relacion:

$table->unsignedInteger('profession_id');
$table->foreign('profession_id')->references('id')->on('professions'); //Create foreign key

Si se intenta asi como me dices pero el problema es que no se crea la relación con la tabla professions aun puedo seguir poniendo id que no existen en dicha tabla

	Intente con los siguientes comandos

	- php artisan migrate:rollback => Para eliminar los lotes de migraciones y dejar limpia la tabla.

	- php artisan migrate:fresh => Para eliminar el contenido de las otras tablas y te ejecute de nuevo las migraciones.

Referencias:

	https://laracasts.com/series/laravel-5-fundamentals/episodes/7


	
	
	
